/// This module provides the functionality to generate coverage reports using tarpaulin.
/// It includes data structures for processing tarpaulin output, as well as methods
/// to extract coverage information for specific functions or items in a crate.
use crate::krate::Krate;
use crate::prelude::*;
use hax_frontend_exporter::Span;
use std::fmt;

/// This module wraps the tarpaulin command line tool, parsing its
/// output in Rust datatypes.
mod tarpaulin_cli_wrapper {
    use super::*;

    /// Represents the statistics gathered for a particular line by tarpaulin.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub enum Stats {
        /// The number of times the line was covered.
        Line(usize),
        /// The number of times the branch was covered.
        Branch(usize),
        /// The number of times the condition was covered.
        Condition(usize),
    }

    impl Stats {
        pub fn covered(&self) -> bool {
            match self {
                Stats::Line(n) | Stats::Branch(n) | Stats::Condition(n) => *n > 0,
            }
        }
    }

    /// Represents a trace of a particular line, including its statistics.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct Trace {
        /// The line number within the source file.
        pub line: usize,
        /// The statistics for the line.
        pub stats: Stats,
    }

    /// Represents a coverage report for a single source file.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct FileReport {
        /// The (absolute) path of the file within the crate.
        pub path: Vec<String>,
        /// The list of traces for lines within the file.
        pub traces: Vec<Trace>,
    }

    /// Represents the full coverage report generated by tarpaulin for all the files detected.
    #[derive(Serialize, Deserialize, Debug, Clone)]
    pub struct TarpaulinReport {
        /// The list of file reports, each containing coverage information for a specific file.
        pub files: Vec<FileReport>,
    }

    impl Krate {
        /// Runs tarpaulin to generate a coverage report for this crate.
        ///
        /// This method invokes the `cargo tarpaulin` command and parses the output as a `TarpaulinReport`.
        ///
        /// # Panics
        /// This method will panic if it fails to run the tarpaulin command or if the output cannot be parsed.
        pub fn tarpaulin(&self) -> TarpaulinReport {
            let mut tarpaulin = self.command("cargo");
            tarpaulin.args(&["tarpaulin", "--out", "Json"]);
            tarpaulin.arg("--output-dir");
            tarpaulin.arg(self.path());
            tarpaulin.args(&["--", "testify_test"]);
            let output = tarpaulin.output().unwrap();
            let path = self.path().join("tarpaulin-report.json");
            use std::fs::File;
            use std::io::BufReader;
            let file = File::open(path).unwrap_or_else(|e| panic!("{e}: {output:#?}"));
            let reader = BufReader::new(file);

            let report = serde_json::from_reader(reader).unwrap();
            trace!("tarpaulin report: {report:#?}");
            report
        }
    }
}

pub use tarpaulin_cli_wrapper::*;

/// Represents the coverage status for a specific line in the source file.
#[derive(Copy, Clone, Debug)]
pub struct LineReport {
    /// The line number within the source file.
    pub line: usize,
    /// Indicates whether the line is covered by a test.
    pub covered: bool,
}

impl From<Trace> for LineReport {
    /// Converts a `Trace` into a `LineReport`, determining whether the line is covered.
    fn from(trace: Trace) -> Self {
        Self {
            line: trace.line,
            covered: trace.stats.covered(),
        }
    }
}

/// Represents the coverage report for a specific item (e.g.,
/// function) within a crate. Note that reports are only about items
/// that have bad coverage.
#[derive(Clone, Debug)]
pub struct BadCoverageReport {
    /// The relative path of the source file containing the item.
    pub relative_path: PathBuf,
    /// The path of the item within the crate (e.g., function name).
    pub item_path: String,
    /// A list of lines in the item, including their coverage status.
    pub lines: Vec<(usize, String, Option<bool>)>,
}

impl TarpaulinReport {
    /// Retrieves the coverage information for a specific file.
    ///
    /// This method returns a list of `LineReport` instances
    /// representing the coverage status of each relevant line in the
    /// specified file. Irrelevant lines are for instance blank lines
    /// or commented lines.
    pub fn lines_for_file(&self, file: &Path) -> Vec<LineReport> {
        self.files
            .iter()
            .flat_map(|file_report| {
                file_report.traces.iter().map(move |r| {
                    (
                        file_report.path.iter().collect::<PathBuf>(),
                        LineReport::from(r.clone()),
                    )
                })
            })
            .filter(|(path, _)| path == &file)
            .map(|(_, line)| line)
            .collect()
    }

    /// Generates a coverage report for a specific span of code within
    /// a file.
    ///
    /// This method returns a `Some` with a `BadCoverageReport` for
    /// the item if any of the lines within the specified span are not
    /// covered by tests.
    ///
    /// # Parameters
    /// - `item_path`: The path to the item within the crate (e.g., `krate::path::to::function`).
    /// - `file`: The path to the source file containing the item.
    /// - `span`: The span of the item within the source file.
    #[tracing::instrument(level = "trace")]
    pub fn coverage_for_span(
        &self,
        item_path: String,
        file: &Path,
        span: Span,
    ) -> Option<BadCoverageReport> {
        let within_range = |line| line >= span.lo.line && line <= span.hi.line;
        let line_reports = self.lines_for_file(&file);
        let lines_status: HashMap<_, _> = line_reports
            .iter()
            .filter(|lr| within_range(lr.line))
            .map(|lr| (lr.line, lr.covered))
            .collect();
        if lines_status.is_empty() {
            return None;
        }
        let contents = std::fs::read_to_string(&file).unwrap();
        let lines: Vec<_> = contents.lines().collect();
        let lines = (span.lo.line..=span.hi.line).map(|line| {
            (
                line,
                lines[line - 1].to_string(),
                lines_status.get(&line).copied(),
            )
        });
        Some(BadCoverageReport {
            lines: lines.collect(),
            item_path,
            relative_path: span.filename.to_path().unwrap_or(file).to_path_buf(),
        })
    }
}

impl fmt::Display for BadCoverageReport {
    /// Formats the `BadCoverageReport` for display.
    ///
    /// This implementation provides a summary of the uncovered lines
    /// in the item, including line numbers, coverage status, and
    /// corresponding source code lines.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        writeln!(
            f,
            "\n{}",
            format!(
                " ╭ ⚠ Item `{}` was not entirely covered.\n │ ↳ You need more contracts or more tests.",
                format!("{}", self.item_path).reversed()
            )
            .bold()
        )?;
        let width = self
            .lines
            .iter()
            .map(|(n, _, _)| *n)
            .max()
            .unwrap_or(4)
            .to_string()
            .len();
        let filler = std::iter::repeat_n(" ", width).collect::<String>();
        for (i, (n, s, c)) in self.lines.iter().enumerate() {
            let n = format!("{filler}{n}");
            let n: String = format!("{filler}{n}")
                .chars()
                .skip(n.len() - width)
                .collect();
            let (c, s) = match c {
                None => (" ".into(), s.dimmed()),
                Some(true) => ("✓".green(), s.green()),
                Some(false) => ("⨯".red(), s.red()),
            };
            let box_char = if i + 1 == self.lines.len() {
                "╰"
            } else {
                "│"
            };
            writeln!(f, " {box_char} {} {c} {s}", n.dimmed())?;
        }
        Ok(())
    }
}
